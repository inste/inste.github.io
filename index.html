<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Tractor Sliding Puzzle Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
    }
    body {
      background: #f8f8fa;
      color: #222;
      font-family: 'Segoe UI', Arial, sans-serif;
      min-height: 100vh;
      width: 100vw;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      justify-content: stretch;
      box-sizing: border-box;
      overscroll-behavior: contain;
    }
    #game-container {
      background: #fff;
      border-radius: 18px;
      box-shadow: 0 4px 32px rgba(0,0,0,0.07);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      width: 100vw;
      height: 100vh;
      max-width: 100vw;
      max-height: 100vh;
      min-height: 100vh;
      box-sizing: border-box;
      padding: 0;
      position: relative;
      overflow: hidden;
      user-select: none;
      touch-action: none;
    }
    #header {
      width: 100%;
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      gap: 12px;
      padding: 24px 24px 0 24px;
      box-sizing: border-box;
      background: #fff;
      z-index: 2;
    }
    #level-select {
      font-size: 18px;
      border-radius: 4px;
      border: none;
      padding: 5px 14px;
      margin-left: 8px;
      background: #e5e5ef;
      color: #222;
      font-weight: 500;
      outline: none;
      box-shadow: 0 2px 6px #0001;
    }
    #puzzle-grid {
      flex: 1;
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      grid-template-rows: repeat(2, 1fr);
      gap: 4vw;
      border-radius: 3vw;
      width: 92vw;
      height: 92vw;
      max-width: 92vh;
      max-height: 92vh;
      background: #eaeaf5;
      margin: 1.5vw auto 0 auto;
      touch-action: none;
      box-sizing: border-box;
      position: relative;
    }
    .tile {
      background: #eee;
      color: #222;
      font-weight: 700;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0;
      border-radius: 2vw;
      transition: transform 0.16s cubic-bezier(.5,1.4,.8,1);
      box-shadow: 0 1px 6px rgba(0,0,0,0.09);
      overflow: hidden;
      cursor: pointer;
      touch-action: none;
      background-size: 200% 200%;
      background-repeat: no-repeat;
      background-color: #fff;
      min-width: 0;
      min-height: 0;
      aspect-ratio: 1 / 1;
    }
    .tile.solved {
      outline: 2px solid #8bc34a;
    }
    #controls {
      width: 100%;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      margin: 0;
      padding: 12px 24px 18px 24px;
      box-sizing: border-box;
      background: #fff;
      z-index: 2;
    }
    #stats {
      font-size: 19px;
      font-weight: 500;
    }
    #preview-btn, #reset-btn {
      background: #e5e5ef;
      color: #222;
      border: none;
      border-radius: 5px;
      padding: 8px 18px;
      font-size: 17px;
      margin: 0 2px;
      cursor: pointer;
      transition: background 0.15s;
      font-weight: 500;
      box-shadow: 0 1px 2px #0001;
    }
    #preview-btn:hover, #reset-btn:hover {
      background: #d4d4ed;
    }
    #preview-modal {
      position: fixed;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: #fff;
      border-radius: 24px;
      padding: 26px 20px 22px 20px;
      z-index: 9999;
      box-shadow: 0 8px 48px #0002;
      display: none;
      flex-direction: column;
      align-items: center;
    }
    #preview-modal img {
      width: 60vw; height: 60vw;
      max-width: 360px; max-height: 360px;
      border-radius: 14px;
      margin-bottom: 10px;
      background: #f8f8fa;
    }
    #close-preview {
      background: #e5e5ef;
      color: #222;
      border: none;
      border-radius: 7px;
      padding: 8px 18px;
      font-size: 17px;
      cursor: pointer;
      margin-top: 4px;
      font-weight: 500;
      box-shadow: 0 1px 2px #0001;
    }
    #win-modal {
      position: fixed;
      z-index: 9999;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: #f0ffe4;
      color: #248d34;
      border-radius: 24px;
      padding: 38px 20px 24px 20px;
      box-shadow: 0 8px 48px #0002;
      display: none;
      flex-direction: column;
      align-items: center;
      text-align: center;
    }
    #win-modal button {
      background: #fff;
      color: #176c1f;
      border: none;
      border-radius: 9px;
      padding: 10px 24px;
      font-size: 21px;
      cursor: pointer;
      margin: 10px 9px 0 9px;
      font-weight: bold;
      box-shadow: 0 1px 2px #0001;
    }
    #footer {
      margin-top: 0;
      color: #999;
      font-size: 14px;
      text-align: center;
      background: #fff;
      padding: 10px 0;
      position: absolute;
      bottom: 0;
      width: 100vw;
      left: 0;
      z-index: 2;
      border-top: 1px solid #eee;
    }
    @media (max-width: 800px) {
      #puzzle-grid {
        width: 96vw;
        height: 96vw;
        max-width: 100vw;
        max-height: 100vw;
        gap: 4vw;
        border-radius: 3vw;
      }
      #preview-modal img {
        width: 85vw; height: 85vw;
        max-width: 360px; max-height: 360px;
      }
    }
    @media (max-width: 600px) {
      #header, #controls {
        padding: 14px 7vw 0 7vw;
      }
      #controls {
        padding: 10px 7vw 14px 7vw;
      }
    }
    @media (max-width: 400px) {
      #puzzle-grid, #preview-modal img {
        width: 99vw !important;
        height: 99vw !important;
        max-width: 99vw !important;
        max-height: 99vw !important;
      }
    }
  </style>
</head>
<body>
  <div id="game-container">
    <div id="header">
      <span>
        Level:
        <select id="level-select"></select>
      </span>
      <button id="preview-btn" aria-label="Show image preview">Preview</button>
    </div>
    <div id="puzzle-grid"></div>
    <div id="controls">
      <span id="stats">Moves: 0 | Time: 0s</span>
      <button id="reset-btn" aria-label="Reset puzzle">Reset</button>
    </div>
    <div id="footer">
      Tractor Puzzle Game &mdash; HTML5 Demo<br>
      Replace images in <code>tractorImages</code> for real tractors!
    </div>
  </div>
  <div id="preview-modal">
    <img id="preview-img" alt="Preview of tractor image for this level">
    <button id="close-preview">Close</button>
  </div>
  <div id="win-modal">
    <h2>ðŸŽ‰ Puzzle Completed!</h2>
    <div id="win-details"></div>
    <button id="next-level-btn">Next Level</button>
    <button id="replay-btn">Replay</button>
  </div>
  <script>
    // --- TRACTOR IMAGE SAMPLES (replace with real photos for production) ---
    const tractorImages = [
        "https://inste.github.io/1.jpg",
        "https://inste.github.io/2.jpg",
        "https://inste.github.io/3.jpg",
        "https://inste.github.io/4.jpg",
        "https://inste.github.io/5.jpg",
        "https://inste.github.io/1.jpg",
        "https://inste.github.io/2.jpg",
        "https://inste.github.io/3.jpg",
        "https://inste.github.io/4.jpg",
        "https://inste.github.io/5.jpg"
    ];

    // --- GLOBAL STATE ---
    const gridSize = 2; // 2x2
    const partCount = gridSize * gridSize;
    let currentLevel = 0;
    let board = [];
    let moveCount = 0;
    let startTime = null;
    let timerInterval = null;
    let gameActive = false;
    let solvedOrder = [];
    let shuffledOrder = [];
    let touchState = null; // {startX, startY, idx}
    let recordTimes = new Array(10).fill(null);

    // --- DOM ---
    const puzzleGrid = document.getElementById('puzzle-grid');
    const stats = document.getElementById('stats');
    const resetBtn = document.getElementById('reset-btn');
    const previewBtn = document.getElementById('preview-btn');
    const previewModal = document.getElementById('preview-modal');
    const previewImg = document.getElementById('preview-img');
    const closePreview = document.getElementById('close-preview');
    const levelSelect = document.getElementById('level-select');
    const winModal = document.getElementById('win-modal');
    const winDetails = document.getElementById('win-details');
    const nextLevelBtn = document.getElementById('next-level-btn');
    const replayBtn = document.getElementById('replay-btn');

    // --- SETUP LEVEL SELECT ---
    tractorImages.forEach((img, i) => {
      const opt = document.createElement('option');
      opt.value = i; opt.textContent = `Level ${i+1}`;
      levelSelect.appendChild(opt);
    });

    levelSelect.addEventListener('change', () => {
      currentLevel = parseInt(levelSelect.value,10);
      startLevel(currentLevel);
    });

    // --- PUZZLE LOGIC ---
    function makeBoard(order) {
      puzzleGrid.innerHTML = '';
      const imgUrl = tractorImages[currentLevel];
      const n = gridSize;
      for (let i = 0; i < partCount; ++i) {
        const tile = document.createElement('div');
        tile.className = 'tile';
        tile.setAttribute('data-idx', i);

        const piece = order[i];
        const row = Math.floor(piece / n);
        const col = piece % n;
        const x = (col / (n - 1)) * 100;
        const y = (row / (n - 1)) * 100;
        tile.style.backgroundImage = `url('${imgUrl}')`;
        tile.style.backgroundSize = `${n * 100}% ${n * 100}%`;
        tile.style.backgroundPosition = `${x}% ${y}%`;
        tile.style.backgroundRepeat = 'no-repeat';
        tile.style.backgroundColor = '#fff';
        puzzleGrid.appendChild(tile);
      }
    }

    function getShuffledOrder() {
      let arr;
      do {
        arr = solvedOrder.slice();
        // Fisher-Yates shuffle
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
      } while (!isSolvable(arr) || isSolved(arr));
      return arr;
    }

    function isSolvable(arr) {
      // For 2x2, only even permutations are solvable
      let inv = 0;
      for (let i = 0; i < partCount; i++) {
        for (let j = i + 1; j < partCount; j++) {
          if (arr[i] > arr[j]) inv++;
        }
      }
      return inv % 2 === 0;
    }

    function isSolved(arr) {
      return arr.every((val,idx)=>val===idx);
    }

    function startLevel(level) {
      currentLevel = level;
      levelSelect.value = level;
      solvedOrder = Array.from({length:partCount}, (_,i)=>i);
      shuffledOrder = getShuffledOrder();
      makeBoard(shuffledOrder);
      moveCount = 0;
      updateStats();
      if (timerInterval) clearInterval(timerInterval);
      startTime = Date.now();
      timerInterval = setInterval(updateStats, 300);
      gameActive = true;
      puzzleGrid.classList.remove('win');
    }

    function updateStats() {
      const t = gameActive ? Math.floor((Date.now()-startTime)/1000) : Math.floor((recordTimes[currentLevel]||0)/1000);
      stats.textContent = `Moves: ${moveCount} | Time: ${t}s`;
    }

    // --- SWIPE CONTROL ---
    function idxToRC(idx) { return [Math.floor(idx/gridSize), idx%gridSize]; }
    function rcToIdx(r,c) { return r*gridSize+c; }

    function moveTile(idx) {
      if (!gameActive) return;
      const [tr, tc] = idxToRC(idx);

      // Find which tile to swap with (must be an adjacent tile)
      // Only allow swaps with adjacent tiles
      const candidates = [
        [tr-1, tc], [tr+1, tc], [tr, tc-1], [tr, tc+1]
      ].filter(([r,c]) => r >= 0 && r < gridSize && c >= 0 && c < gridSize);
      for (const [r,c] of candidates) {
        const swapIdx = rcToIdx(r,c);
        if (swapIdx !== idx) {
          // swap tiles
          [shuffledOrder[idx], shuffledOrder[swapIdx]] = [shuffledOrder[swapIdx], shuffledOrder[idx]];
          makeBoard(shuffledOrder);
          moveCount++;
          updateStats();
          if (isSolved(shuffledOrder)) winGame();
          return;
        }
      }
    }

    function onTouchStart(e) {
      if (!gameActive) return;
      let touch = e.touches ? e.touches[0] : e;
      const el = document.elementFromPoint(touch.clientX, touch.clientY);
      if (!el || !el.classList.contains('tile')) return;
      touchState = {startX: touch.clientX, startY: touch.clientY, idx: parseInt(el.getAttribute('data-idx'))};
      e.preventDefault();
    }
    function onTouchMove(e) {
      if (!touchState) return;
      let touch = e.touches ? e.touches[0] : e;
      const dx = touch.clientX - touchState.startX, dy = touch.clientY - touchState.startY;
      if (Math.abs(dx) < 32 && Math.abs(dy) < 32) return;
      let dir = Math.abs(dx) > Math.abs(dy) ? (dx > 0 ? 'right':'left') : (dy > 0 ? 'down':'up');
      const idx = touchState.idx;
      const [r,c] = idxToRC(idx);
      let ni = -1;
      if (dir==='up' && r>0) ni = rcToIdx(r-1,c);
      if (dir==='down' && r<gridSize-1) ni = rcToIdx(r+1,c);
      if (dir==='left' && c>0) ni = rcToIdx(r,c-1);
      if (dir==='right' && c<gridSize-1) ni = rcToIdx(r,c+1);
      if (ni!==-1) {
        [shuffledOrder[idx], shuffledOrder[ni]] = [shuffledOrder[ni], shuffledOrder[idx]];
        makeBoard(shuffledOrder);
        moveCount++;
        updateStats();
        if (isSolved(shuffledOrder)) winGame();
        touchState = null;
      }
      e.preventDefault();
    }
    function onTouchEnd(e) {
      touchState = null;
    }
    function onClickTile(e) {
      if (!gameActive) return;
      const el = e.target.closest('.tile');
      if (!el) return;
      moveTile(parseInt(el.getAttribute('data-idx')));
    }

    // --- EVENT BINDINGS ---
    puzzleGrid.addEventListener('touchstart', onTouchStart, {passive:false});
    puzzleGrid.addEventListener('touchmove', onTouchMove, {passive:false});
    puzzleGrid.addEventListener('touchend', onTouchEnd, {passive:false});
    puzzleGrid.addEventListener('mousedown', onTouchStart);
    puzzleGrid.addEventListener('mousemove', onTouchMove);
    puzzleGrid.addEventListener('mouseup', onTouchEnd);
    puzzleGrid.addEventListener('click', onClickTile);

    resetBtn.addEventListener('click', ()=>startLevel(currentLevel));

    previewBtn.addEventListener('click', ()=>{
      previewImg.src = tractorImages[currentLevel];
      previewModal.style.display = 'flex';
    });
    closePreview.addEventListener('click', ()=>previewModal.style.display='none');

    function winGame() {
      gameActive = false;
      clearInterval(timerInterval);
      recordTimes[currentLevel] = Date.now()-startTime;
      winDetails.innerHTML = `<b>Level ${currentLevel+1}</b><br>Moves: ${moveCount}<br>Time: ${Math.floor(recordTimes[currentLevel]/1000)}s`;
      winModal.style.display = 'flex';
    }
    nextLevelBtn.addEventListener('click', ()=>{
      winModal.style.display='none';
      if (currentLevel<tractorImages.length-1) startLevel(++currentLevel);
      else startLevel(0);
    });
    replayBtn.addEventListener('click', ()=>{
      winModal.style.display='none';
      startLevel(currentLevel);
    });

    // --- INIT ---
    startLevel(0);

    // --- PROGRESS SAVE/LOAD (optional, localStorage) ---
    // You can uncomment below for persistent progress
    /*
    function saveProgress() {
      localStorage.setItem('tractorPuzzle-progress', JSON.stringify({
        level: currentLevel,
        moveCount,
        startTime,
        recordTimes
      }));
    }
    function loadProgress() {
      const data = localStorage.getItem('tractorPuzzle-progress');
      if (data) {
        const {level, recordTimes:rt} = JSON.parse(data);
        currentLevel = level || 0;
        recordTimes = rt || recordTimes;
      }
    }
    window.addEventListener('beforeunload', saveProgress);
    loadProgress();
    */
  </script>
</body>
</html>
